<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pods in Kubernetes</title>
      <link href="/2020/07/01/Pods-in-Kubernetes/"/>
      <url>/2020/07/01/Pods-in-Kubernetes/</url>
      
        <content type="html"><![CDATA[<p>In docker, a container is the smallest unit, while in kubernetes, <strong>pods</strong> are the most basic building blocks. </p><p><em>Note: kubernetes can use container runtimes other than docker</em></p><p>A <strong>pod</strong> contains one or more containers, and each <strong>pod</strong> has:</p><ul><li>A single IP address</li><li>Share localhost</li><li>A shared IPC space</li><li>A shared network port range</li><li>Shared volumes</li></ul><blockquote><p>Everything in a <strong>pod</strong> is tightly coupled.</p><p>A <strong>pod</strong> is a way to represent a running process in a cluster.  (A container is also just a running process.)</p></blockquote><h2 id="Run-Pods-with-kubectl"><a href="#Run-Pods-with-kubectl" class="headerlink" title="Run Pods with kubectl"></a>Run Pods with kubectl</h2><p>Before doing anything, we must create a <strong>kubernetes cluster</strong> first:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ minikube start --vm-driver=virtualbox</span><br></pre></td></tr></table></figure><p>We can run a pod using the following command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run NAME --image=image [--env=<span class="string">"key=value"</span>] [--port=port] [--dry-run=server|client] [--overrides=inline-json] [--<span class="built_in">command</span>] -- [COMMAND] [args...]</span><br></pre></td></tr></table></figure><p>For example, you can a nginx server like following:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run nginx --image=nginx --generator <span class="string">"run-pod/v1"</span></span><br><span class="line">pod/nginx created</span><br></pre></td></tr></table></figure><p>We can verify that a pod was created by running:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx                   1/1     Running   0          4s</span><br></pre></td></tr></table></figure><p>We can ssh into minikube to confirm that a container created from the latest nignx image is running inside of the cluster:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ minikube ssh</span><br><span class="line">$ docker container ls -f ancestor=nginx</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">4f5ceb7b8921        nginx               <span class="string">"/docker-entrypoint.…"</span>   2 minutes ago       Up 2 minutes                            k8s_nginx_nginx_default_620758d2-c891-4ee4-a507-306257de8a74_0</span><br><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>We can also link our docker client with the docker server inside of minikube:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> $(minikube docker-env)</span><br><span class="line">$ docker container ls -f ancestor=nginx</span><br></pre></td></tr></table></figure><p>To delete a pod, run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete ([-f FILENAME] | [-k DIRECTORY] | TYPE [(NAME | -l label | --all)])</span><br></pre></td></tr></table></figure><p>So we can run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pod nginx</span><br><span class="line">pod <span class="string">"nginx"</span> deleted</span><br></pre></td></tr></table></figure><h3 id="Why-this-is-bad-practice"><a href="#Why-this-is-bad-practice" class="headerlink" title="Why this is bad practice?"></a>Why this is bad practice?</h3><p>In the above, we manually created a pod running ngnix image. This is just a simple application with only one node. <em>What if we have a complex application which needs thousands of nodes?</em> Creating all these nodes manually is very tedious and error-prone. Even if we created all these nodes, we can’t possibly reproduce this result easily or even correctly.</p><h4 id="Infrastructure-as-Code"><a href="#Infrastructure-as-Code" class="headerlink" title="Infrastructure as Code"></a>Infrastructure as Code</h4><p>Instead of running pods in an <strong>imperative</strong> way, as shown above, we should run them in a <strong>declarative</strong> way. We want to define all the pods we need in files and let kubernetes to manage the process of creating all these pods. This way, our infrastructure can be documented, just like code, so we can easily store, share, and reproduce it.</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> pods </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
